// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct AuditRegistryProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for AuditRegistryProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = AuditRegistryProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        AuditRegistryProxyMethods { wrapped_tx: tx }
    }
}

pub struct AuditRegistryProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> AuditRegistryProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AuditRegistryProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn register_audit<
        Arg0: ProxyArg<ManagedByteArray<Env::Api, 32usize>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        contract_hash: Arg0,
        stars: Arg1,
        summary: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("register_audit")
            .argument(&contract_hash)
            .argument(&stars)
            .argument(&summary)
            .original_result()
    }

    pub fn get_all_audits<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        start_index: Arg0,
        limit: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue5<ManagedByteArray<Env::Api, 32usize>, u8, ManagedBuffer<Env::Api>, ManagedAddress<Env::Api>, u64>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("get_all_audits")
            .argument(&start_index)
            .argument(&limit)
            .original_result()
    }

    pub fn get_total_contracts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalContracts")
            .original_result()
    }

    pub fn get_contract_audits<
        Arg0: ProxyArg<ManagedByteArray<Env::Api, 32usize>>,
    >(
        self,
        contract_hash: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, Audit<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getContractAudits")
            .argument(&contract_hash)
            .original_result()
    }

    pub fn get_auditor_history<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        auditor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedByteArray<Env::Api, 32usize>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAuditorHistory")
            .argument(&auditor)
            .original_result()
    }

    pub fn get_latest_audit<
        Arg0: ProxyArg<ManagedByteArray<Env::Api, 32usize>>,
    >(
        self,
        contract_hash: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Audit<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLatestAudit")
            .argument(&contract_hash)
            .original_result()
    }

    pub fn withdraw(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdraw")
            .original_result()
    }

    pub fn owner(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOwner")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, ManagedVecItem, Clone, Debug)]
pub struct Audit<Api>
where
    Api: ManagedTypeApi,
{
    pub stars: u8,
    pub summary: ManagedBuffer<Api>,
    pub auditor: ManagedAddress<Api>,
    pub timestamp: u64,
}
